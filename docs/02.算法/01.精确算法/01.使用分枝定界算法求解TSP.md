---
title: 使用分枝定界算法求解TSP
date: 2022-11-21 15:46:38
permalink: /pages/e85c89/
---


## 分枝定界法（Branch and Bound）

在线性规划问题中，有一类特殊的变量，它的取值只能是**非负整数**，如果所有的变量都限定为此类变量，那么就称之为纯整数线性规划，如果仅限制一部分变量为整数，那么就称为混合整数规划。

显然，直接使用单纯形法或者将单纯形法求得的最优解“化整”，所得的结果都不会是原整数规划的最优解。由于变量非负整数的限制，容易想到的办法是穷举变量的所有取值，比较它们的目标值从而得出最优解，这在问题规模较小时当然可行，但在问题规模较大时，穷举法就捉襟见肘了。

单纯形法求解线性规划的原理是在可行锥的顶点之间反复迭代，最终得到最优解，因此实际上参与比较的解仅仅是很少一部分，整数规划虽不能直接套用单纯形法，但也可以借鉴一二，这就是分枝定界法（Branch and Bound），它由 Land Doig 和 Dakin 等人提出，目前已是求解整数规划的重要方法，Cplex 等商业软件也是基于 B&B 框架的。

### B&B 核心思想

现有一个优化问题 $A$，其解空间为 $S$，分支定界的目的就是为了从解空间中找到一个解 $x$，使得目标函数值 $f (x)$ 最大化或者最小化，由于所有的最大化问题都可以转化为最小化问题，因此可以说 B&B 只为寻找**最小化问题**的最优解。

分枝定界算法的核心如其名所示，在于两个点
- 分枝（Branch）。将解空间通过递归手段分解成为许多个子空间，在每个子空间中对 $f (x)$ 进行最小化，此谓之分枝。
- 定界（Bound）。如果只有分枝，那么搜索解空间的过程就成了暴力穷举法，所以需要对每个分枝进行**下界**计算，对于目标函数值已经超过当前下界的子空间，就进行剪枝，此之谓定界。

示意图如下所示，对于目标函数值下界超过当前下界的分枝，在后续搜索过程中不必再考虑，至于下界如何确定，后面我们会给出答案。

![](https://cdn.jsdelivr.net/gh/musoulee/figurebed/figures/202211211547182.png)

### B&B 求解 ILP

为了方便理解，我们以一个纯整数规划的问题来介绍 B&B，例如下面的问题。

$$
\begin{align}
\max & \quad z = 40x_1 + 90x_2 \\
s.t. & \\
& 9x_1 + 7x_2 \leqslant 56 \\
& 7x_1 + 20x_2 \leqslant 70 \\
& x_1, x_2 \geqslant 0 \\
& x_1, x_2 \in N
\end{align}
$$
首先将目标函数转化为 $min \quad \omega = -40 x_1 - 90 x _2$ ，设为问题 B，然后不考虑整数约束，直接求解对应的线性规划，最优解为 $x^* = (4.81,1.82), \quad \omega^* = -356$ ，显然其不符合整数解，但-356 是原问题的一个下界，也就是说任何整数解的目标函数值都不可能比这个解更小了。

然后考虑将问题 B 分解为子问题 B1 和 B2，分割的办法为从 $x_1, x_2$ 中选择一个变量，譬如 $x_1$, 给它添加新的约束条件 $x_1 \leqslant 4$ 和 $x_1 \geqslant 5$，分别对应问题 B1 和问题 B2。这样两个子问题的最优解中使得目标函数最小化的那个解就是原问题的最优解。

整个分枝+定界的过程如下图所示

![](https://cdn.jsdelivr.net/gh/musoulee/figurebed/figures/202211211547082.png)


下面我来解释一下这个流程
- 第一步，添加约束 $x_1 \leqslant 4$ 和 $x_1 \geqslant 5$，将问题 B 分解成问题 B1 和问题 B2 分别求解。
- 第二步，由于 $-349 < -341$，所以选择问题 B1 继续分解，添加约束 $x_2 \leqslant 2$ 和 $x_2 \geqslant 3$，将其分解为 B3 和 B4。
- 第三步，问题 B3 **已是整数解**（可行解），且由于 $-340 < -327$，故无需再分解问题 B4。但问题 B2 下的分枝可能会有比-340 更优的目标函数值存在，故添加约束分解 B2。
- 第四步，由问题 B2 分解得到的 B5 和 B6，一个下界大于-340，一个无可行解，因此都无需再继续分解，最优解已经找到。

### B&B 通用框架

> 以下资料来自维基百科

下面是最小化任意目标函数 $f$ 的通用分枝定界算法框架。要从中得到一个算法，我们需要一个边界函数 $bound$，用来计算函数 $f$ 在搜索树节点上的下界，以及一个基于特定问题的分支规则。

1. 首先使用启发式算法找出一个优化问题的解 $x_h$, 并存储数值 $B=f (x_h)$。（如果无法通过启发法找到解，则设 $B$ 的值为无穷大）$B$ 表示到目前为止找到的最佳解，并把它作为候选解的上界。
2. 初始化一个**队列**，用于存储在不进行变量分配时所得到的局部解。
3. 执行如下循环直至队列被清空
	 - 从队列中取出节点 $N$。
    - 如果节点 $N$，代表单一的候选解 $x$ 且满足 $f (x) < B$，那么我们就可以说 $x$ 为目前所找到的最佳解，令 $B \leftarrow f (x)$。
    - 反之，节点 $N$ 产生新的分支节点 $N_i$，对于这些新产生的节点：
        - 如果 $bound (N_i) > B$，则舍弃该节点，因为最优解不可能出现在这个节点里。
        - 反之，将节点 $N_i$ 存入队列。


在这一算法中，队列也可以替换为其他的数据结构。在使用遵循**先进先出**原则的队列时，该算法属于**广度优先搜索**。反之如果使用遵循先进后出的**堆栈**储存节点，该算法就成为了**深度优先搜索**。当然，也可以使用**优先队列**对所有的节点的下界进行排序，进一步提升效率采用这种算法的例子是 Dijkstra 算法及其衍生的 A\*搜索算法。

:::tip
当无法通过启发法生成初始解时，建议使用深度优先算法的变体，因为它可以快速生成完整解，从而得到整个问题的上界。
:::

## B&B 求解 TSP 问题

现在我们已经了解了分枝定界法的通用框架，并且已经会用它解决纯整数规划的问题，那么 B&B 能不能用来解决混合整数规划问题呢，答案当然是肯定的。这一节将以 TSP 问题为例，来介绍如何使用分枝定界法较为快速地求得最优解，有关 TSP 问题的介绍请看[旅行商问题](/pages/be2b74/#旅行商问题)。

由于众所周知的原因，TSP 问题是很难求得最优解的，而如果将其拓展到 VRP 问题后，即便是可行解也较难得出了，因此，在使用分枝定界法求解 TSP 时，常采用的手段是**深度优先搜索**的方法，从而迅速得到一个可行解（问题的上界），再来与其他解的下界来做比较。

假设一个 TSP 问题有 5 个节点，首先初始化各节点之间的距离矩阵为
$$
D = \begin{bmatrix}
\infty & 20 & 30 & 10 & 11 \\
15 & \infty & 16 & 4 & 2 \\
3 & 5 & \infty & 2 & 4\\
19 & 6 & 18 & \infty & 3\\
16 & 4 & 7 & 16 & \infty
\end{bmatrix}
$$
如果将 TSP 问题用一个图来表示，那么在其任意一个可行解中，每个节点都有与之相关联的两条边，利用这个特性，我们可以很方便地求得 TSP 的一个下界：在矩阵 $D$ 中，第 $i$ 行的最小值代表从节点 $i$ 离开的最小成本，第 $j$ 列的最小值代表进入节点 $j$ 的最小成本。



为了方便计算，可以对上述矩阵进行化简：先令每行元素减去该行最小元素得到矩阵 $D^\prime$，再令每列元素减去该列最小元素得到矩阵 $D^{\prime\prime}$，这样，矩阵 $D{^\prime\prime}$ 每行每列的最小元素为 0。
$$
D \rightarrow \begin{bmatrix}
\infty & 10 & 20 & 0 & 1 \\
13 & \infty & 14 & 2 & 0\\
1 & 3 & \infty & 0 & 2\\
16 & 3 & 15 & \infty & 0\\
12 & 0 & 3 & 12 & \infty
\end{bmatrix}
\rightarrow
\begin{bmatrix}
\infty & 10 & 17 & 0 & 1 \\
12 & \infty & 11 & 2 & 0\\
0 & 3 & \infty & 0 & 2\\
15 & 3 & 12 & \infty & 0\\
11 & 0 & 0 & 12 & \infty
\end{bmatrix}
\rightarrow D^{\prime\prime}
$$
根据前文，TSP 问题的最小成本为 $c_{min} = \sum_i \min_j d_{ij} + \sum_j \min_i d^\prime_{ij}$，在上面这个问题中，$c_{min} = (10 + 2 + 2 + 3 + 4) + (1+3) = 21+4=25$。

> 在后面的讨论中，$c (i, j)$ 代表矩阵 $D^{\prime\prime}$ 第 $i$ 行第 $j$ 列的值。

首先将节点 1 加入局部解，然后枚举还未加入局部解的节点 2，3，4，5，将它们分别与 1 相连，构成新的局部解。

以 $1\rightarrow 2$ 为例，我们将矩阵 $D^{\prime\prime}$ 的第一行和第二列以及点 (2, 1) 赋值为∞，表示节点 1 没有其他出边，节点 2 没有其他入边，且不存在子回路，这样就得到矩阵 $D_{12}$，对应的成本为 $c_{12} = c (1, 2)+ c_{min} + \delta (D_{12}) = 35$ ，**其中 $\delta (D_{12})$ 表示矩阵 $D_{12}$ 进行与矩阵 $D$ 相同的操作后所得到的最小成本**。
$$
\begin{bmatrix}
\infty & \infty & \infty & \infty & \infty \\
\infty & \infty & 9 & 0 & 0\\
0 & \infty & \infty & 0 & 2\\
15 & \infty & 12 & \infty & 0\\
11 & \infty & 0 & 12 & \infty
\end{bmatrix}
\rightarrow D_{12}
$$
相应的，$c_{13} = 17 + 25 + 11 = 53, c_{14} = 25, c_{15} = 1 + 25 + 5 = 31$，对应的矩阵分别为
$$
\begin{aligned}
\begin{bmatrix}
\infty & \infty & \infty & \infty & \infty \\
1 & \infty & \infty & 2 & 0\\
\infty & 3 & \infty & 0 & 2\\
4 & 3 & \infty & \infty & 0\\
0 & 0 & \infty & 12 & \infty
\end{bmatrix}
\rightarrow D_{13}\\
\\
\begin{bmatrix}
\infty & \infty & \infty & \infty & \infty \\
12 & \infty & 11 & \infty & 0\\
0 & 3 & \infty & \infty & 2\\
\infty & 3 & 12 & \infty & 0\\
11 & 0 & 0 & \infty & \infty
\end{bmatrix}
\rightarrow D_{14}\\
\\
\begin{bmatrix}
\infty & \infty & \infty & \infty & \infty \\
10 & \infty & 9 & 0 & \infty\\
0 & 3 & \infty & 0 & \infty\\
12 & 0 & 9 & \infty & \infty\\
\infty & 0 & 0 & 12 & \infty
\end{bmatrix}
\rightarrow D_{15}
\end{aligned}
$$
算法的状态搜索树如下图所示，当找到一个可行解 $1\rightarrow 4 \rightarrow 2 \rightarrow 5 \rightarrow 3$ 后，更新 $B=28$，这时便按照 DFS 开始剪枝。

![](https://cdn.jsdelivr.net/gh/musoulee/figurebed/figures/202211211553245.png)



## Java + Cplex 代码实现


> 前面我们只是知道了怎样去计算 TSP，那么如何将这个过程描述为算法，方便使用程序语言实现呢？

为了方便描述算法，我在这里预先定义一些符号：
- $I$ ：表示在搜索过程中产生的局部解。
- $i$ ：表示局部解 $I$ 的当前搜索节点。
- $Q$ ：用于存储所有局部解的一个容器，这里是栈+优先队列的组合，栈中元素为一个优先队列，存储每一层的所有局部解。
- $N$ ：所有节点的集合。
- $S_I$ ：已经加入某一个局部解的所有节点。
- $V_I$ ：还未加入某一个局部解的所有节点。
- $c_I$ ：某一局部解的成本下界。
- $B$ ：问题的解的上界。

**使用分枝定界算法求解 TSP 的步骤如下：**

- 初始令 $Q=\emptyset, B=\infty$，任选一节点 $i$ 构成局部解 $I$ 进入 $Q$。
- 当 $Q$ 不为空时，执行如下循环：
	- 取出栈顶优先队列中满足 $c_I$ 最小的局部解，如果 $c_I > B$，说明以后所有可行解都不如当前的解，于是退出循环。
	- 如果 $V_I = \emptyset$，代表 $I$ 是一个可行解，此时如果 $c_I < B$，更新 $B = c_I$。
	- 如果 $V_I \neq \emptyset$，代表 $I$ 仅仅是一个局部解，分别将 $V_I$ 中的节点逐个加入 $I$，形成 $I^\prime$ 的集合，将这个集合存入优先队列，压入栈 $Q$。



## 参考资料

- [Youtube-vehicle routing problem](https://www.youtube.com/watch?v=A1wsIFDKqBk&t=2717s) []
- [Youtube-TSP (Branch and bound)](https://youtu.be/1FEP_sNb62k)